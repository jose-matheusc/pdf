package com.async.pdf.service.pdf;

import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.PDPage;
import org.apache.pdfbox.pdmodel.PDPageContentStream;
import org.apache.pdfbox.pdmodel.common.PDRectangle;
import org.apache.pdfbox.pdmodel.font.PDFont;
import org.apache.pdfbox.pdmodel.font.PDType1Font;
import org.springframework.stereotype.Service;

import java.awt.*;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

@Service
public class PdfService {

    private static final float MARGIN = 50;
    private static final Color HEADER_COLOR = new Color(32, 105, 255);
    private static final Color HEADER_COLOR_DARK = new Color(18, 66, 168);

    private record StyledLine(String text, boolean bold) {
    }

    public void createPdf(String content, String path) throws IOException {

        try (PDDocument doc = new PDDocument()) {

            PDFont titleFont = PDType1Font.HELVETICA_BOLD;
            PDFont bodyFont = PDType1Font.HELVETICA;

            PDPage page = new PDPage(PDRectangle.A4);
            doc.addPage(page);
            PDRectangle media = page.getMediaBox();

            PDPageContentStream cs = new PDPageContentStream(doc, page);

            // HEADER
            drawGradientHeader(cs, media);

            // Title
            cs.beginText();
            cs.setFont(titleFont, 22);
            cs.setNonStrokingColor(Color.WHITE);
            cs.newLineAtOffset(MARGIN, media.getHeight() - 55);
            cs.showText("Smart Reporting");
            cs.endText();

            cs.beginText();
            cs.setFont(bodyFont, 11);
            cs.setNonStrokingColor(Color.WHITE);
            cs.newLineAtOffset(MARGIN, media.getHeight() - 75);
            cs.showText("Automatically generated by the system");
            cs.endText();

            float y = media.getHeight() - 130;

            cs.setNonStrokingColor(new Color(70, 70, 70));
            cs.beginText();
            cs.setFont(titleFont, 16);
            cs.newLineAtOffset(MARGIN, y);
            cs.endText();

            y -= 30;

            float cardWidth = media.getWidth() - (MARGIN * 2);
            float cardPadding = 10;
            float leading = 14f;
            float paddingTop = 16f;
            float paddingBottom = 12f;
            float bottomLimit = MARGIN + 50;

            List<StyledLine> lines = wrapMarkdownText(bodyFont, titleFont, content, cardWidth - (cardPadding * 2));

            int idx = 0;
            while (idx < lines.size()) {
                float pageTopY = y;
                float textStartY = pageTopY - paddingTop;

                int linesPerPage = (int) Math.floor((textStartY - bottomLimit - paddingBottom) / leading);
                if (linesPerPage < 1) linesPerPage = 1;
                int end = Math.min(lines.size(), idx + linesPerPage);
                List<StyledLine> pageLines = lines.subList(idx, end);

                float cardHeight = paddingTop + pageLines.size() * leading + paddingBottom;
                cs.setNonStrokingColor(new Color(245, 245, 245));
                cs.addRect(MARGIN, pageTopY - cardHeight, cardWidth, cardHeight);
                cs.fill();
                cs.setStrokingColor(new Color(200, 200, 200));
                cs.addRect(MARGIN, pageTopY - cardHeight, cardWidth, cardHeight);
                cs.stroke();

                float textX = MARGIN + cardPadding;
                cs.beginText();
                cs.setLeading(leading);
                cs.setNonStrokingColor(Color.BLACK);
                cs.newLineAtOffset(textX, textStartY);
                for (StyledLine sl : pageLines) {
                    cs.setFont(sl.bold ? PDType1Font.HELVETICA_BOLD : PDType1Font.HELVETICA, 11);
                    if (sl.text.isEmpty()) {
                        cs.newLine();
                    } else {
                        cs.showText(sl.text);
                        cs.newLine();
                    }
                }
                cs.endText();

                idx = end;

                if (idx < lines.size()) {
                    drawFooter(cs);
                    cs.close();

                    page = new PDPage(PDRectangle.A4);
                    doc.addPage(page);
                    media = page.getMediaBox();
                    cs = new PDPageContentStream(doc, page);

                    drawGradientHeader(cs, media);

                    y = media.getHeight() - 130;
                    cs.setNonStrokingColor(new Color(70, 70, 70));
                    cs.beginText();
                    cs.setFont(titleFont, 16);
                    cs.newLineAtOffset(MARGIN, y);
                    cs.endText();

                    y -= 30;
                }
            }

            drawFooter(cs);

            cs.close();
            doc.save(path);
        }
    }

    private void drawGradientHeader(PDPageContentStream cs, PDRectangle media) throws IOException {
        float headerHeight = 100;
        int steps = 20;
        for (int i = 0; i < steps; i++) {
            float t = (float) i / steps;
            Color c = blend(t);
            cs.setNonStrokingColor(c);
            cs.addRect(0, media.getHeight() - headerHeight + (i * (headerHeight / steps)),
                    media.getWidth(), headerHeight / steps);
            cs.fill();
        }
    }

    private Color blend(float t) {
        return new Color(
                (int) (PdfService.HEADER_COLOR.getRed() * (1 - t) + PdfService.HEADER_COLOR_DARK.getRed() * t),
                (int) (PdfService.HEADER_COLOR.getGreen() * (1 - t) + PdfService.HEADER_COLOR_DARK.getGreen() * t),
                (int) (PdfService.HEADER_COLOR.getBlue() * (1 - t) + PdfService.HEADER_COLOR_DARK.getBlue() * t)
        );
    }

    private void drawFooter(PDPageContentStream cs) throws IOException {
        cs.beginText();
        cs.setFont(PDType1Font.HELVETICA_OBLIQUE, 9);
        cs.setNonStrokingColor(new Color(120, 120, 120));
        cs.newLineAtOffset(MARGIN, 35);
        cs.showText("Sistema Async PDF");
        cs.endText();
    }

    // Basic Markdown-aware wrapper: supports headings (##), full-line bold (**line**), bullets (* or -),
    // preserves blank lines; filters control chars and wraps greedily by width.
    private List<StyledLine> wrapMarkdownText(PDFont normalFont, PDFont boldFont, String text, float max) throws IOException {
        List<StyledLine> out = new ArrayList<>();
        if (text == null || text.isEmpty()) return out;

        String normalized = text
                .replace("\r\n", "\n")
                .replace('\r', '\n')
                .replaceAll("[\\p{Cntrl}&&[^\\n]]", " ");

        String[] paragraphs = normalized.split("\n", -1);
        for (String raw : paragraphs) {
            String paragraph = raw;
            if (paragraph.isBlank()) {
                out.add(new StyledLine("", false));
                continue;
            }

            boolean bold = false;
            // headings like '## Title'
            if (paragraph.startsWith("## ")) {
                bold = true;
                paragraph = paragraph.substring(3).trim();
            } else if (paragraph.startsWith("# ")) {
                bold = true;
                paragraph = paragraph.substring(2).trim();
            }

            // full-line bold like **Text**
            if (paragraph.matches("\\*\\*(.+)\\*\\*")) {
                bold = true;
                paragraph = paragraph.replaceAll("^\\*\\*(.+)\\*\\$", "$1");
                paragraph = paragraph.replaceAll("^\\*\\*(.+)\\*\\*$", "$1");
            }

            // bullets: start with '* ' or '- '
            if (paragraph.startsWith("* ") || paragraph.startsWith("- ")) {
                paragraph = "- " + paragraph.substring(2).trim(); // avoid using â€¢ which may be unsupported
            }

            // remove remaining markdown bold markers in-line (simple)
            paragraph = paragraph.replace("**", "");

            // Wrap greedily by width using the appropriate font per line style
            PDFont measureFont = bold ? boldFont : normalFont;

            String[] words = paragraph.split("\\s+");
            StringBuilder line = new StringBuilder();
            for (String word : words) {
                String test = line.isEmpty() ? word : line + " " + word;
                float w = measureFont.getStringWidth(test) / 1000f * (float) 11.0;
                if (w > max) {
                    if (line.isEmpty()) {
                        out.add(new StyledLine(word, bold));
                    } else {
                        out.add(new StyledLine(line.toString(), bold));
                        line = new StringBuilder(word);
                    }
                } else {
                    if (line.isEmpty()) line.append(word);
                    else line.append(' ').append(word);
                }
            }
            out.add(new StyledLine(line.toString(), bold));
        }
        return out;
    }
}
